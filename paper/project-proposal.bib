@article{algeff,
    title = {An Introduction to Algebraic Effects and Handlers. {Invited} tutorial paper},
    journal = {Electronic Notes in Theoretical Computer Science},
    volume = {319},
    pages = {19-35},
    year = {2015},
    note = {The 31st Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXI).},
    issn = {1571-0661},
    doi = {https://doi.org/10.1016/j.entcs.2015.12.003},
    author = {Matija Pretnar},
    keywords = {algebraic effects, handlers, effect system, semantics, logic, tutorial},
    abstract = {This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type & effect system, show how one can reason about effects, and give pointers for further reading.}
}

@misc{unison,
    author = {{Unison Computing}},
    title = {The {Unison} language},
    year = {2021},
    note = {Last accessed 24 February 2022},
    url = {https://www.unisonweb.org/}
}

@misc{unrestricted,
    author = {{Unison Computing}},
    title = {Unison language reference. {Pattern} matching on ability constructors},
    year = {2021},
    note = {Last accessed 24 February 2022},
    url = {https://www.unisonweb.org/docs/language-reference#pattern-matching-on-ability-constructors},
}

@techreport{koka,
    author = {Leijen, Daan},
    title = {Algebraic Effects for Functional Programming},
    year = {2016},
    month = {August},
    abstract = {Algebraic effect handlers, are recently gaining in popularity as a purely functional approach to modeling effects. In this article, we give an end-to-end overview of practical algebraic effects in the context of a compiled implementation in the Koka language. In particular, we show how algebraic effects generalize over common constructs like exception handling, state, iterators and async-await. We give an effective type inference algorithm based on extensible effect rows using scoped labels, and a direct operational semantics. Finally, we show an efficient compilation scheme to common runtime platforms (such as JavaScript, the JVM, or .NET) using a type directed selective CPS translation.},
    pages = {15},
    number = {MSR-TR-2016-29},
    institution = {Microsoft Research},
}

@article{rowkoka,
   title={Koka: Programming with Row Polymorphic Effect Types},
   volume={153},
   ISSN={2075-2180},
   doi={http://dx.doi.org/10.4204/EPTCS.153.8},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Leijen, Daan},
   year={2014},
   month={Jun},
   pages={100–126}
}

@misc{hidden,
    author = {Daan Leijen},
    title = {The {Koka} Programming Language. {Effect} Handlers},
    year = {2022},
    note = {Last accessed 24 February 2022},
    url = {https://koka-lang.github.io/koka/doc/book.html#sec-handlers},
}

@article{bauer,
   title={{Runners in Action}},
   ISBN={9783030449148},
   ISSN={1611-3349},
   doi={http://dx.doi.org/10.1007/978-3-030-44914-8_2},
   journal={Lecture Notes in Computer Science},
   publisher={Springer International Publishing},
   author={Ahman, Danel and Bauer, Andrej},
   year={2020},
   pages={29–55},
}

@article{ocaml,
   title={Retrofitting effect handlers onto {OCaml}},
   doi={http://dx.doi.org/10.1145/3453483.3454039},
   journal={Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
   publisher={ACM},
   author={Sivaramakrishnan, KC and Dolan, Stephen and White, Leo and Kelly, Tom and Jaffer, Sadiq and Madhavapeddy, Anil},
   year={2021},
   month={Jun}
}

@misc{folklore,
    author = {KC Sivaramakrishnan},
    title = {Effective Concurrency with Algebraic Effects},
    year = {2015},
    note = {Last accessed 24 February 2022},
    url = {https://kcsrk.info/ocaml/multicore/2015/05/20/effects-multicore/},
}

@inproceedings{rowcaml,
    author = {Garrigue, Jacques},
    year = {1998},
    month = {10},
    pages = {},
    title = {Programming with Polymorphic Variants},
    booktitle = {ACM SIGPLAN Workshop on ML},
    address = {Baltimore, MD}
}

@inproceedings{mtl,
    author = {Jones, Mark P.},
    title = {Functional Programming with Overloading and Higher-Order Polymorphism},
    year = {1995},
    isbn = {3540594515},
    publisher = {Springer-Verlag},
    address = {Berlin, Heidelberg},
    booktitle = {Advanced Functional Programming, First International Spring School on Advanced Functional Programming Techniques-Tutorial Text},
    pages = {97–136},
}

@misc{free,
    author = {Edward Kmett},
    title = {Monads for Free},
    year = {2008},
    note = {Last accessed 24 February 2022},
    url = {http://comonad.com/reader/2008/monads-for-free/},
}

@article{exteff,
    author = {Kiselyov, Oleg and Ishii, Hiromi},
    title = {Freer Monads, More Extensible Effects},
    year = {2015},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {50},
    number = {12},
    issn = {0362-1340},
    doi = {https://doi.org/10.1145/2887747.2804319},
    abstract = { We present a rational reconstruction of extensible effects, the recently proposed alternative to monad transformers, as the confluence of efforts to make effectful computations compose. Free monads and then extensible effects emerge from the straightforward term representation of an effectful computation, as more and more boilerplate is abstracted away. The generalization process further leads to freer monads, constructed without the Functor constraint. The continuation exposed in freer monads can then be represented as an efficient type-aligned data structure. The end result is the algorithmically efficient extensible effects library, which is not only more comprehensible but also faster than earlier implementations. As an illustration of the new library, we show three surprisingly simple applications: non-determinism with committed choice (LogicT), catching IO exceptions in the presence of other effects, and the semi-automatic management of file handles and other resources through monadic regions. We extensively use and promote the new sort of `laziness', which underlies the left Kan extension: instead of performing an operation, keep its operands and pretend it is done. },
    journal = {SIGPLAN Not.},
    month = {aug},
    pages = {94–105},
    keywords = {free monad, type and effect system, Kan extension, coroutine, effect handler, effect interaction, open union}
}

@incollection{ghc,
    author = {Simon Marlow and Simon Peyton-Jones},
    title = {{The Glasgow Haskell Compiler}},
    booktitle = {The Architecture of Open Source Applications, Volume II},
    editor = {Brown, A. and Wilson, G.},
    pages = {67--88},
    isbn = {9781105571817},
    year = {2012},
    publisher = {CreativeCommons}
}

@article{linear,
   title={Linear {Haskell}: practical linearity in a higher-order polymorphic language},
   volume={2},
   ISSN={2475-1421},
   doi={http://dx.doi.org/10.1145/3158093},
   number={POPL},
   journal={Proceedings of the ACM on Programming Languages},
   publisher={Association for Computing Machinery (ACM)},
   author={Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Peyton Jones, Simon and Spiwack, Arnaud},
   year={2018},
   month={Jan},
   pages={1–29}
}


@article{rust,
    author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
    title = {{RustBelt}: Securing the Foundations of the {Rust} Programming Language},
    year = {2017},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {2},
    number = {POPL},
    doi = {https://doi.org/10.1145/3158154},
    abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
    journal = {Proc. ACM Program. Lang.},
    month = {dec},
    keywords = {Rust, separation logic, logical relations, type systems, concurrency}
}

@article{ural,
    author = {Ahmed, Amal and Fluet, Matthew and Morrisett, Greg},
    title = {A Step-Indexed Model of Substructural State},
    year = {2005},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {40},
    number = {9},
    issn = {0362-1340},
    doi = {https://doi.org/10.1145/1090189.1086376},
    abstract = {The concept of a "unique" object arises in many emerging programming languages such as Clean, CQual, Cyclone, TAL, and Vault. In each of these systems, unique objects make it possible to perform operations that would otherwise be prohibited (e.g., deallocating an object) or to ensure that some obligation will be met (e.g., an opened file will be closed). However, different languages provide different interpretations of "uniqueness" and have different rules regarding how unique objects interact with the rest of the language.Our goal is to establish a common model that supports each of these languages, by allowing us to encode and study the interactions of the different forms of uniqueness. The model we provide is based on a substructural variant of the polymorphic λ-calculus, augmented with four kinds of mutable references: unrestricted, relevant, affine, and linear. The language has a natural operational semantics that supports deallocation of references, strong (type-varying) updates, and storage of unique objects in shared references. We establish the strong soundness of the type system by constructing a novel, semantic interpretation of the types.},
    journal = {SIGPLAN Not.},
    month = {sep},
    pages = {78–91},
    keywords = {substructural type system, stepindexed model, mutable references}
}

@techreport{stone,
  title = {Equational Theories with Recursive Types},
  author = {Christopher A. Stone and Andrew P. Schoonmaker},
  institution = {Harvey Mudd College},
  year = {2005}
}
